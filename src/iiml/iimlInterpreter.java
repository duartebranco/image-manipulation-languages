import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.awt.image.BufferedImage;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.BasicStroke;
@SuppressWarnings("unused")

public class iimlInterpreter extends iimlBaseVisitor<Value> {
    private Map<String, Value> memory = new HashMap<>();
    private BufferedImage currentImage = null;
    private Graphics2D graphics = null;
    private final Scanner scanner = new Scanner(System.in);
    private String inputFilename = "input.iiml";  // Default value

    // Add constructor to accept the filename
    public iimlInterpreter(String inputFilename) {
        if (inputFilename != null && !inputFilename.isEmpty()) {
            this.inputFilename = inputFilename;
        }
    }

    // Add a default constructor for backward compatibility
    public iimlInterpreter() {
        // Use default filename
    }
    
    public void execute() {
        // Display the final image if one was created
        if (currentImage != null) {
            // Create a simple frame to display the image
            javax.swing.JFrame frame = new javax.swing.JFrame("IIML Image");
            frame.setDefaultCloseOperation(javax.swing.JFrame.EXIT_ON_CLOSE);
            frame.setSize(currentImage.getWidth() + 50, currentImage.getHeight() + 50);
            frame.add(new javax.swing.JLabel(new javax.swing.ImageIcon(currentImage)));
            frame.setVisible(true);
            // Save the image to a file with the name of the input file
            try {
                String baseFilename = new java.io.File(inputFilename).getName();
                String outputFilename = baseFilename.replaceFirst("[.][^.]+$", "") + ".pgm"; 
                
                // Create output directory if it doesn't exist
                new java.io.File("output").mkdirs();
                
                // Write in PGM format directly
                java.io.PrintWriter writer = new java.io.PrintWriter(new java.io.File("output/" + outputFilename));
                writer.println("P2"); // PGM ASCII format
                writer.println("# Generated by IIML Interpreter");
                writer.println(currentImage.getWidth() + " " + currentImage.getHeight());
                writer.println("255"); // Max gray value
                
                // Write pixel data
                for (int y = 0; y < currentImage.getHeight(); y++) {
                    for (int x = 0; x < currentImage.getWidth(); x++) {
                        int gray = currentImage.getRaster().getSample(x, y, 0);
                        writer.print(gray + " ");
                    }
                    writer.println();
                }
                writer.close();
                
                System.out.println("Image saved as " + outputFilename + " in output/ directory");
            } catch (java.io.IOException e) {
                System.err.println("Error saving image: " + e.getMessage());
            }
        }
    }
    
    @Override
    public Value visitVariableDeclaration(iimlParser.VariableDeclarationContext ctx) {
        String id = ctx.ID().getText();
        
        String typeStr = ctx.type().getText();
        Value value = visit(ctx.expression());
        
        // Perform type checking here if needed
        
        memory.put(id, value);
        return value;
    }
    
    @Override
    public Value visitImageStatement(iimlParser.ImageStatementContext ctx) {
        Value width = visit(ctx.expression(0));
        Value height = visit(ctx.expression(1));
        Value background = visit(ctx.expression(2));
        
        int w = (int)width.asNumber();
        int h = (int)height.asNumber();
        double bg = background.asNumber();
        
        // Create a new image with the specified dimensions and background
        BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_BYTE_GRAY);
        
        // Fill with background color (0 = black, 1 = white)
        int grayValue = (int)(bg * 255); 
        //System.out.println("Background gray value: " + grayValue); // Debug print
        
        for (int y = 0; y < h; y++) {
            for (int x = 0; x < w; x++) {
                image.getRaster().setSample(x, y, 0, grayValue);
            }
        }
        
        currentImage = image;
        graphics = image.createGraphics();
        
        return new Value(image);
    }
    
    @Override
    public Value visitPlaceStatement(iimlParser.PlaceStatementContext ctx) {
        if (currentImage == null) {
            throw new RuntimeException("No active image to draw on");
        }
        
        String shape = ctx.shape().getText();
        Value radius = visit(ctx.expression(0));
        Value x = visit(ctx.expression(1));
        Value y = visit(ctx.expression(2));
        Value intensity = visit(ctx.expression(3));
        
        int r = (int)radius.asNumber();
        int centerX = (int)x.asNumber();
        int centerY = (int)y.asNumber();
        double intensityVal = intensity.asNumber();
        
        int grayValue = (int)(intensityVal * 255);
        int width = currentImage.getWidth();
        int height = currentImage.getHeight();
        
        // Draw directly on the raster for grayscale images
        switch (shape) {
            case "circle":
                // Draw filled circle using raster
                for (int py = Math.max(0, centerY - r); py < Math.min(height, centerY + r); py++) {
                    for (int px = Math.max(0, centerX - r); px < Math.min(width, centerX + r); px++) {
                        int dx = px - centerX;
                        int dy = py - centerY;
                        if (dx*dx + dy*dy <= r*r) {
                            currentImage.getRaster().setSample(px, py, 0, grayValue);
                        }
                    }
                }
                break;
            case "rect":
                // Draw filled rectangle using raster
                for (int py = Math.max(0, centerY - r); py < Math.min(height, centerY + r); py++) {
                    for (int px = Math.max(0, centerX - r); px < Math.min(width, centerX + r); px++) {
                        currentImage.getRaster().setSample(px, py, 0, grayValue);
                    }
                }
                break;
            case "cross":
                // Draw cross using raster
                int thickness = Math.max(1, r/5);
                for (int py = Math.max(0, centerY - r); py < Math.min(height, centerY + r); py++) {
                    for (int px = Math.max(0, centerX - r); px < Math.min(width, centerX + r); px++) {
                        int dx = px - centerX;
                        int dy = py - centerY;
                        if (Math.abs(dx - dy) <= thickness || Math.abs(dx + dy) <= thickness) {
                            currentImage.getRaster().setSample(px, py, 0, grayValue);
                        }
                    }
                }
                break;
            case "plus":
                // Draw plus using raster
                thickness = Math.max(1, r/5);
                for (int py = Math.max(0, centerY - r); py < Math.min(height, centerY + r); py++) {
                    for (int px = Math.max(0, centerX - r); px < Math.min(width, centerX + r); px++) {
                        int dx = px - centerX;
                        int dy = py - centerY;
                        if (Math.abs(dx) <= thickness || Math.abs(dy) <= thickness) {
                            currentImage.getRaster().setSample(px, py, 0, grayValue);
                        }
                    }
                }
                break;
            default:
                throw new RuntimeException("Unknown shape: " + shape);
        }
        
        return new Value(currentImage);
    }

    @Override
    public Value visitOutputStatement(iimlParser.OutputStatementContext ctx) {
        Value value = visit(ctx.expression());
        System.out.println(value.toString());
        return value;
    }
    
    @Override
    public Value visitReadExpr(iimlParser.ReadExprContext ctx) {
        // Remove quotes from the prompt string
        String prompt = ctx.STRING().getText();
        prompt = prompt.substring(1, prompt.length() - 1);
        System.out.print(prompt);
        System.out.flush(); // Add this line to ensure prompt is displayed
        String input = scanner.nextLine();
        return new Value(input);
    }
    
    @Override
    public Value visitNumberConversionExpr(iimlParser.NumberConversionExprContext ctx) {
        Value value = visit(ctx.expression());
        try {
            double number = Double.parseDouble(value.asString());
            return new Value(number);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Cannot convert to number: " + value.asString());
        }
    }

    
    
    @Override
    public Value visitStringConversionExpr(iimlParser.StringConversionExprContext ctx) {
        Value value = visit(ctx.expression());
        return new Value(value.toString());
    }
    
    @Override
    public Value visitAssignment(iimlParser.AssignmentContext ctx) {
        String id = ctx.ID().getText();
        Value value = visit(ctx.expression());
        
        // Check if variable exists
        if (!memory.containsKey(id)) {
            throw new RuntimeException("Undefined variable: " + id);
        }
        
        memory.put(id, value);
        return value;
    }
    
    @Override
    public Value visitArithmeticAddSubExpr(iimlParser.ArithmeticAddSubExprContext ctx) {
        Value left = visit(ctx.left);
        Value right = visit(ctx.right);
        String op = ctx.operator.getText();
        
        if (left.getType() == Value.Type.STRING && right.getType() == Value.Type.STRING && op.equals("+")) {
            // String concatenation
            return new Value(left.asString() + right.asString());
        } else if ((left.getType() == Value.Type.NUMBER || left.getType() == Value.Type.PERCENTAGE) &&
                  (right.getType() == Value.Type.NUMBER || right.getType() == Value.Type.PERCENTAGE)) {
            // Numeric operation
            double result;
            switch (op) {
                case "+":
                    result = left.asNumber() + right.asNumber();
                    break;
                case "-":
                    result = left.asNumber() - right.asNumber();
                    break;
                default:
                    throw new RuntimeException("Unknown operator: " + op);
            }
            
            if (left.getType() == Value.Type.PERCENTAGE || right.getType() == Value.Type.PERCENTAGE) {
                return new Value(result, true); // Return as percentage
            } else {
                return new Value(result); // Return as number
            }
        } else {
            throw new RuntimeException("Type error: Cannot apply operator " + op + 
                                      " to types " + left.getType() + " and " + right.getType());
        }
    }
    
    @Override
    public Value visitArithmeticMulDivExpr(iimlParser.ArithmeticMulDivExprContext ctx) {
        Value left = visit(ctx.left);
        Value right = visit(ctx.right);
        String op = ctx.operator.getText();
        
        if ((left.getType() == Value.Type.NUMBER || left.getType() == Value.Type.PERCENTAGE) &&
            (right.getType() == Value.Type.NUMBER || right.getType() == Value.Type.PERCENTAGE)) {
            // Numeric operation
            double result;
            switch (op) {
                case "*":
                    result = left.asNumber() * right.asNumber();
                    break;
                case "/":
                    if (right.asNumber() == 0) {
                        throw new RuntimeException("Division by zero");
                    }
                    result = left.asNumber() / right.asNumber();
                    break;
                default:
                    throw new RuntimeException("Unknown operator: " + op);
            }
            
            if (left.getType() == Value.Type.PERCENTAGE || right.getType() == Value.Type.PERCENTAGE) {
                return new Value(result, true); // Return as percentage
            } else {
                return new Value(result); // Return as number
            }
        } else {
            throw new RuntimeException("Type error: Cannot apply operator " + op + 
                                     " to types " + left.getType() + " and " + right.getType());
        }
    }
    
    @Override
    public Value visitParenExpr(iimlParser.ParenExprContext ctx) {
        return visit(ctx.expression());
    }
    
    @Override
    public Value visitPrimary(iimlParser.PrimaryContext ctx) {
        if (ctx.ID() != null) {
            String id = ctx.ID().getText();
            if (!memory.containsKey(id)) {
                throw new RuntimeException("Undefined variable: " + id);
            }
            return memory.get(id);
        } else if (ctx.NUMBER() != null) {
            return new Value(Double.parseDouble(ctx.NUMBER().getText()));
        } else if (ctx.PERCENTAGE() != null) {
            String text = ctx.PERCENTAGE().getText();
            double value = Double.parseDouble(text.substring(0, text.length() - 1));
            return new Value(value, true);
        } else if (ctx.STRING() != null) {
            String text = ctx.STRING().getText();
            return new Value(text.substring(1, text.length() - 1)); // Remove quotes
        } else if (ctx.list() != null) {
            return visit(ctx.list());
        }
        throw new RuntimeException("Unknown primary expression");
    }
    
    @Override
    public Value visitList(iimlParser.ListContext ctx) {
        List<Value> values = new ArrayList<>();
        for (iimlParser.ExpressionContext expr : ctx.expression()) {
            values.add(visit(expr));
        }
        return new Value(values);
    }
}